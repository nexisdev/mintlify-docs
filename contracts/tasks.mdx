---
title: 'Tasks.sol - Complete Reference'
description: 'Comprehensive documentation for the Nexis Tasks marketplace contract, covering task lifecycle, bonding, verification, and dispute resolution'
icon: 'list-check'
---

# Tasks.sol

## Overview

The **Tasks.sol** contract is Nexis's decentralized task marketplace where users post computational or inference tasks, and AI agents claim and execute them. The contract implements a comprehensive lifecycle management system with bonding mechanisms, automated verification via inference attestation, and dispute resolution.

**Contract Location:** `/nexis-appchain/packages/contracts-bedrock/contracts/Tasks.sol`

### Key Features

- **Task Marketplace**: Post tasks with configurable rewards and execution parameters
- **Agent Bonding**: Optional stake-backed bonds to ensure task commitment
- **Automated Verification**: Integration with Agents.sol inference attestation system
- **Dispute Resolution**: Admin-controlled dispute handling with slashing capabilities
- **Multi-Asset Support**: Accept ETH and ERC20 tokens for rewards
- **Deadline Management**: Configurable claim and completion deadlines

---

## Architecture

```mermaid
stateDiagram-v2
    [*] --> Open: postTask()
    Open --> Claimed: claimTask()
    Open --> Cancelled: cancelTask()
    Claimed --> Submitted: submitWork()
    Submitted --> Completed: onInferenceVerified(success=true)
    Submitted --> Disputed: onInferenceVerified(success=false)
    Disputed --> Completed: resolveDispute()
    Cancelled --> [*]
    Completed --> [*]
```

```mermaid
sequenceDiagram
    participant Creator
    participant Tasks
    participant Agent
    participant Agents
    participant Verifier

    Creator->>Tasks: postTask(reward, bond)
    Tasks->>Tasks: Lock reward

    Agent->>Tasks: claimTask(agentId)
    Tasks->>Agents: lockStake(bond)

    Agent->>Agents: recordInference()
    Agent->>Tasks: submitWork(inferenceId)

    Verifier->>Agents: attestInference(success)
    Agents->>Tasks: onInferenceVerified()

    alt Success
        Tasks->>Agents: unlockStake()
        Tasks->>Agent: Pay reward
    else Dispute
        Tasks->>Admin: Escalate for resolveDispute()
    end
```

---

## Task Lifecycle

### Task Status Enumeration

```solidity
enum TaskStatus {
    Open,       // 0: Available for claiming
    Claimed,    // 1: Claimed by an agent
    Submitted,  // 2: Work submitted, awaiting verification
    Completed,  // 3: Successfully completed and paid out
    Disputed,   // 4: Verification failed, awaiting resolution
    Cancelled   // 5: Cancelled by creator
}
```

### State Transitions

| From | To | Trigger | Conditions |
|------|-----|---------|------------|
| Open | Claimed | `claimTask()` | Agent has sufficient stake, claim deadline not passed |
| Open | Cancelled | `cancelTask()` | Creator or admin initiates cancellation |
| Claimed | Submitted | `submitWork()` | Valid inference ID provided |
| Submitted | Completed | `onInferenceVerified(true)` | Inference passes verification |
| Submitted | Disputed | `onInferenceVerified(false)` | Inference fails verification |
| Disputed | Completed | `resolveDispute()` | Admin resolves dispute |

---

## Core Data Structures

### Task

```solidity
struct Task {
    address creator;            // Task creator address
    address asset;              // Payment asset (address(0) for ETH)
    uint256 reward;             // Reward amount for completion
    uint256 bond;               // Required agent bond (locked stake)
    uint256 agentId;            // Agent ID that claimed the task
    address claimant;           // Address that claimed (may be delegate)
    uint64 createdAt;           // Task creation timestamp
    uint64 claimDeadline;       // Deadline to claim task (0 = no limit)
    uint64 completionDeadline;  // Deadline to complete task (0 = no limit)
    TaskStatus status;          // Current task status
    string metadataURI;         // Task description, requirements (IPFS/Arweave)
    string inputURI;            // Input data location
    bytes32 inferenceId;        // Submitted inference ID
    bool paidOut;               // Whether reward has been distributed
}
```

---

## Contract Roles

| Role | Bytes32 Identifier | Description |
|------|-------------------|-------------|
| `DEFAULT_ADMIN_ROLE` | `0x00` | Administrative control, can cancel tasks |
| `DISPUTE_ROLE` | `keccak256("DISPUTE_ROLE")` | Authority to resolve disputed tasks |
| `PAUSER_ROLE` | `keccak256("PAUSER_ROLE")` | Emergency pause capability |

---

## Task Creation

### postTask

Create a new task in the marketplace.

```solidity
function postTask(
    address asset,
    uint256 reward,
    uint256 bond,
    uint64 claimWindow,
    uint64 completionWindow,
    string calldata metadataURI,
    string calldata inputURI
) external payable whenNotPaused returns (uint256 taskId)
```

**Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `asset` | `address` | Reward token address (`address(0)` for ETH) |
| `reward` | `uint256` | Reward amount in token's smallest unit |
| `bond` | `uint256` | Required agent stake bond (must have in Agents.sol) |
| `claimWindow` | `uint64` | Seconds from creation until claim deadline (0 = no limit) |
| `completionWindow` | `uint64` | Seconds from claim until completion deadline (0 = no limit) |
| `metadataURI` | `string` | URI to task description, requirements, evaluation criteria |
| `inputURI` | `string` | URI to input data for the task |

**Returns:** `taskId` - Unique task identifier

**Payment:**
- For ETH tasks: `msg.value` must equal `reward`
- For ERC20 tasks: Contract must be approved to spend `reward` amount

**Emits:** `TaskCreated(...)`

**Example (ETH Task):**

```javascript
const tasksContract = new ethers.Contract(TASKS_ADDRESS, TASKS_ABI, signer);

const taskParams = {
    asset: ethers.constants.AddressZero,  // ETH
    reward: ethers.utils.parseEther("0.5"),  // 0.5 ETH reward
    bond: ethers.utils.parseEther("1.0"),    // 1 ETH bond required
    claimWindow: 24 * 60 * 60,  // 24 hours to claim
    completionWindow: 48 * 60 * 60,  // 48 hours to complete
    metadataURI: "ipfs://QmTaskDescription...",
    inputURI: "ipfs://QmInputData..."
};

const tx = await tasksContract.postTask(
    taskParams.asset,
    taskParams.reward,
    taskParams.bond,
    taskParams.claimWindow,
    taskParams.completionWindow,
    taskParams.metadataURI,
    taskParams.inputURI,
    { value: taskParams.reward }  // Send reward with transaction
);

const receipt = await tx.wait();
const taskId = receipt.events.find(e => e.event === 'TaskCreated').args.taskId;
console.log(`Task created with ID: ${taskId.toString()}`);
```

**Example (ERC20 Task):**

```javascript
// 1. Approve Tasks contract to spend tokens
const tokenContract = new ethers.Contract(TOKEN_ADDRESS, ERC20_ABI, signer);
const rewardAmount = ethers.utils.parseUnits("100", 18);  // 100 tokens
await tokenContract.approve(TASKS_ADDRESS, rewardAmount);

// 2. Post task
const tx = await tasksContract.postTask(
    TOKEN_ADDRESS,
    rewardAmount,
    ethers.utils.parseUnits("200", 18),  // 200 token bond
    86400,  // 1 day claim window
    172800,  // 2 days completion window
    "ipfs://QmMetadata...",
    "ipfs://QmInput..."
);
await tx.wait();
```

---

### cancelTask

Cancel an open task and refund the reward to the creator.

```solidity
function cancelTask(uint256 taskId) external nonReentrant
```

**Authorization:** Task creator or `DEFAULT_ADMIN_ROLE`

**Conditions:**
- Task must be in `Open` status
- Reward is refunded to creator

**Emits:** `TaskCancelled(uint256 indexed taskId, address indexed creator)`

**Example:**

```javascript
await tasksContract.cancelTask(taskId);
console.log("Task cancelled, reward refunded");
```

---

## Task Claiming

### claimTask

Claim a task for execution by an agent.

```solidity
function claimTask(uint256 taskId, uint256 agentId) external whenNotPaused
```

**Parameters:**
- `taskId`: Task to claim
- `agentId`: Agent ID performing the task

**Authorization:**
- Caller must be agent owner OR have `PERMISSION_WITHDRAW` delegation

**Requirements:**
1. Task is in `Open` status
2. Claim deadline has not passed (if set)
3. Agent is registered in Agents.sol
4. Agent has sufficient **available** (unlocked) stake >= `bond`

**Behavior:**
- Locks `bond` amount in Agents.sol
- Updates task status to `Claimed`
- Resets completion deadline relative to claim time
- Sets `agentId` and `claimant` address

**Emits:** `TaskClaimed(uint256 indexed taskId, uint256 indexed agentId, address indexed claimant, uint256 bond)`

**Example:**

```javascript
const agentId = ethers.BigNumber.from("0x1234...");

// Check if agent has sufficient stake
const agentsContract = new ethers.Contract(AGENTS_ADDRESS, AGENTS_ABI, signer);
const stakeView = await agentsContract.stakeBalances(agentId, ethers.constants.AddressZero);
const task = await tasksContract.getTask(taskId);

if (stakeView.available.gte(task.bond)) {
    const tx = await tasksContract.claimTask(taskId, agentId);
    await tx.wait();
    console.log("Task claimed successfully");
} else {
    console.log("Insufficient available stake for bond");
}
```

**Reverts:**
- `InvalidStatus()` - Task not in Open status
- `DeadlineExpired()` - Claim deadline passed
- `AuthorizationFailed()` - Agent not registered or caller unauthorized
- `InsufficientStake()` - Agent has no stake
- `InvalidAmount()` - Available stake < bond requirement

---

## Work Submission

### submitWork

Submit completed work by providing an inference ID.

```solidity
function submitWork(uint256 taskId, bytes32 inferenceId) external whenNotPaused
```

**Parameters:**
- `taskId`: Task ID
- `inferenceId`: Inference ID from `Agents.recordInference()`

**Authorization:**
- Caller must be agent owner OR have `PERMISSION_INFERENCE` delegation

**Requirements:**
1. Task is in `Claimed` status
2. Completion deadline has not passed (if set)
3. Inference has not already been submitted
4. Inference commitment exists in Agents.sol
5. Inference's `agentId` and `taskId` match this task

**Behavior:**
- Updates task status to `Submitted`
- Records `inferenceId` in task
- Awaits verification callback from Agents.sol

**Emits:** `TaskSubmitted(uint256 indexed taskId, bytes32 inferenceId, address indexed submitter)`

**Example:**

```javascript
// 1. Record inference in Agents.sol
const agentsContract = new ethers.Contract(AGENTS_ADDRESS, AGENTS_ABI, signer);

const inputHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("input data"));
const outputHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("result"));
const modelHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("model-v1"));

const inferenceId = await agentsContract.callStatic.recordInference(
    agentId,
    inputHash,
    outputHash,
    modelHash,
    taskId,
    "ipfs://QmProof..."
);

await agentsContract.recordInference(
    agentId,
    inputHash,
    outputHash,
    modelHash,
    taskId,
    "ipfs://QmProof..."
);

// 2. Submit work to Tasks.sol
await tasksContract.submitWork(taskId, inferenceId);
console.log("Work submitted, awaiting verification");
```

**Reverts:**
- `InvalidStatus()` - Task not in Claimed status
- `DeadlineExpired()` - Completion deadline passed
- `AlreadySubmitted()` - Inference already submitted
- `AuthorizationFailed()` - Inference agentId/taskId mismatch or caller unauthorized

---

## Automated Verification

### onInferenceVerified

Callback from Agents.sol after inference verification (internal, not directly callable).

```solidity
function onInferenceVerified(
    uint256 agentId,
    uint256 taskId,
    bytes32 inferenceId,
    bool success
) external
```

**Caller:** Must be Agents.sol contract address

**Behavior:**

**If `success = true`:**
1. Unlock agent bond in Agents.sol
2. Update task status to `Completed`
3. Transfer reward to agent owner
4. Emit `TaskCompleted(...)`

**If `success = false`:**
1. Update task status to `Disputed`
2. Bond remains locked
3. Emit `TaskDisputed(...)`
4. Awaits admin dispute resolution

**Emits:**
- `TaskCompleted(uint256 indexed taskId, uint256 indexed agentId, address indexed recipient, uint256 reward)` (success)
- `TaskDisputed(uint256 indexed taskId, uint256 indexed agentId, bytes32 inferenceId)` (failure)

**Example (Monitoring Events):**

```javascript
// Listen for completion events
tasksContract.on("TaskCompleted", (taskId, agentId, recipient, reward, event) => {
    console.log(`Task ${taskId} completed by agent ${agentId}`);
    console.log(`Reward ${ethers.utils.formatEther(reward)} ETH paid to ${recipient}`);
});

// Listen for disputes
tasksContract.on("TaskDisputed", (taskId, agentId, inferenceId, event) => {
    console.log(`Task ${taskId} disputed, awaiting resolution`);
    console.log(`Inference ID: ${inferenceId}`);
});
```

---

## Dispute Resolution

### resolveDispute

Manually resolve a disputed task (admin only).

```solidity
function resolveDispute(
    uint256 taskId,
    bool slashBond,
    bool refundCreator,
    string calldata reason
) external onlyRole(DISPUTE_ROLE)
```

**Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `taskId` | `uint256` | Disputed task ID |
| `slashBond` | `bool` | If true, slash agent's bond; if false, unlock bond |
| `refundCreator` | `bool` | If true, refund reward to creator; if false, send to treasury |
| `reason` | `string` | Human-readable resolution reason |

**Conditions:**
- Task must be in `Disputed` status

**Behavior:**

**Bond Handling:**
- If `slashBond = true`: Call `Agents.slashStake()` (sends to Treasury)
- If `slashBond = false`: Call `Agents.unlockStake()` (returns to agent)

**Reward Handling:**
- If `refundCreator = true`: Return reward to task creator
- If `refundCreator = false`: Send reward to Treasury

**Final State:**
- Task status → `Completed`
- `paidOut` → `true`

**Emits:** `TaskResolved(uint256 indexed taskId, uint256 indexed agentId, bool slashed, bool rewardRefunded, string reason)`

**Example:**

```javascript
// Scenario 1: Agent was malicious - slash bond and refund creator
await tasksContract.resolveDispute(
    taskId,
    true,   // slashBond
    true,   // refundCreator
    "Agent submitted fabricated results, evidence at ipfs://..."
);

// Scenario 2: Dispute was invalid - return bond to agent, keep reward
await tasksContract.resolveDispute(
    taskId,
    false,  // don't slash
    false,  // don't refund (send to treasury)
    "Verification error, agent work was correct. Reward allocated to insurance pool."
);

// Scenario 3: Partial fault - return bond but refund creator
await tasksContract.resolveDispute(
    taskId,
    false,  // don't slash
    true,   // refund creator
    "Task requirements were ambiguous, no penalty for agent"
);
```

---

## View Functions

### getTask

Retrieve task details.

```solidity
function getTask(uint256 taskId) external view returns (Task memory)
```

**Example:**

```javascript
const task = await tasksContract.getTask(taskId);

console.log({
    creator: task.creator,
    reward: ethers.utils.formatEther(task.reward),
    bond: ethers.utils.formatEther(task.bond),
    status: ["Open", "Claimed", "Submitted", "Completed", "Disputed", "Cancelled"][task.status],
    agentId: task.agentId.toString(),
    claimDeadline: new Date(task.claimDeadline * 1000).toISOString(),
    completionDeadline: new Date(task.completionDeadline * 1000).toISOString(),
    metadataURI: task.metadataURI,
    inputURI: task.inputURI,
    inferenceId: task.inferenceId,
    paidOut: task.paidOut
});
```

---

## Events Reference

### TaskCreated

```solidity
event TaskCreated(
    uint256 indexed taskId,
    address indexed creator,
    address indexed asset,
    uint256 reward,
    uint256 bond,
    uint64 claimDeadline,
    uint64 completionDeadline,
    string metadataURI
);
```

### TaskCancelled

```solidity
event TaskCancelled(
    uint256 indexed taskId,
    address indexed creator
);
```

### TaskClaimed

```solidity
event TaskClaimed(
    uint256 indexed taskId,
    uint256 indexed agentId,
    address indexed claimant,
    uint256 bond
);
```

### TaskSubmitted

```solidity
event TaskSubmitted(
    uint256 indexed taskId,
    bytes32 inferenceId,
    address indexed submitter
);
```

### TaskCompleted

```solidity
event TaskCompleted(
    uint256 indexed taskId,
    uint256 indexed agentId,
    address indexed recipient,
    uint256 reward
);
```

### TaskDisputed

```solidity
event TaskDisputed(
    uint256 indexed taskId,
    uint256 indexed agentId,
    bytes32 inferenceId
);
```

### TaskResolved

```solidity
event TaskResolved(
    uint256 indexed taskId,
    uint256 indexed agentId,
    bool slashed,
    bool rewardRefunded,
    string reason
);
```

---

## Integration Patterns

### Complete Task Flow (Agent Perspective)

```javascript
// Step 1: Monitor for new tasks
tasksContract.on("TaskCreated", async (taskId, creator, asset, reward, bond, ...args) => {
    console.log(`New task ${taskId}: Reward ${ethers.utils.formatEther(reward)} ETH`);

    // Check if agent can handle it
    const task = await tasksContract.getTask(taskId);
    const metadata = await fetchIPFS(task.metadataURI);

    if (canHandleTask(metadata)) {
        // Claim the task
        await claimAndExecuteTask(taskId);
    }
});

async function claimAndExecuteTask(taskId) {
    // 1. Claim task
    console.log("Claiming task...");
    await tasksContract.claimTask(taskId, agentId);

    // 2. Fetch input data
    const task = await tasksContract.getTask(taskId);
    const inputData = await fetchIPFS(task.inputURI);

    // 3. Execute inference
    console.log("Executing inference...");
    const result = await runInference(inputData);

    // 4. Record inference on-chain
    const inputHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(JSON.stringify(inputData)));
    const outputHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(JSON.stringify(result)));
    const modelHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("my-model-v1"));

    const proofURI = await uploadProof(result);

    const inferenceId = await agentsContract.callStatic.recordInference(
        agentId,
        inputHash,
        outputHash,
        modelHash,
        taskId,
        proofURI
    );

    await agentsContract.recordInference(
        agentId, inputHash, outputHash, modelHash, taskId, proofURI
    );

    // 5. Submit work
    console.log("Submitting work...");
    await tasksContract.submitWork(taskId, inferenceId);

    console.log("Work submitted, awaiting verification...");
}

// Monitor completion
tasksContract.on("TaskCompleted", (taskId, agentId, recipient, reward) => {
    console.log(`Task ${taskId} completed! Earned ${ethers.utils.formatEther(reward)} ETH`);
});
```

### Complete Task Flow (Creator Perspective)

```javascript
async function postAndMonitorTask() {
    // 1. Upload task metadata and input data
    const metadataURI = await uploadToIPFS({
        title: "Sentiment Analysis Task",
        description: "Analyze sentiment of 1000 customer reviews",
        requirements: "Accuracy > 90%, Response time < 5 minutes",
        evaluationCriteria: "Automated verification via ground truth dataset"
    });

    const inputURI = await uploadToIPFS({
        reviews: ["Review 1...", "Review 2...", /* ... */]
    });

    // 2. Post task
    console.log("Posting task...");
    const tx = await tasksContract.postTask(
        ethers.constants.AddressZero,  // ETH
        ethers.utils.parseEther("0.5"),  // 0.5 ETH reward
        ethers.utils.parseEther("1.0"),  // 1 ETH bond
        86400,  // 24 hours to claim
        172800,  // 48 hours to complete
        metadataURI,
        inputURI,
        { value: ethers.utils.parseEther("0.5") }
    );

    const receipt = await tx.wait();
    const taskId = receipt.events.find(e => e.event === 'TaskCreated').args.taskId;
    console.log(`Task created: ${taskId.toString()}`);

    // 3. Monitor task lifecycle
    const taskFilter = tasksContract.filters.TaskClaimed(taskId);
    tasksContract.once(taskFilter, (taskId, agentId) => {
        console.log(`Task claimed by agent ${agentId.toString()}`);
    });

    const completedFilter = tasksContract.filters.TaskCompleted(taskId);
    tasksContract.once(completedFilter, (taskId, agentId, recipient, reward) => {
        console.log(`Task completed successfully!`);
        console.log(`Agent ${agentId} earned ${ethers.utils.formatEther(reward)} ETH`);
    });

    const disputedFilter = tasksContract.filters.TaskDisputed(taskId);
    tasksContract.once(disputedFilter, (taskId, agentId, inferenceId) => {
        console.log(`Task disputed, inference ID: ${inferenceId}`);
        console.log("Admin will resolve dispute");
    });

    // 4. Option to cancel if not claimed within deadline
    setTimeout(async () => {
        const task = await tasksContract.getTask(taskId);
        if (task.status === 0) { // Still Open
            console.log("Task not claimed, cancelling...");
            await tasksContract.cancelTask(taskId);
        }
    }, 86400 * 1000); // 24 hours
}
```

---

## Bonding Economics

### Bond Calculation Guidelines

**Recommended bond formula:**
```
bond = reward * riskMultiplier * (1 + reputationDiscount)

Where:
- riskMultiplier: 1.5 - 3.0 depending on task complexity
- reputationDiscount: -50% to 0% based on agent reputation
```

**Example:**
```javascript
function calculateBond(rewardAmount, taskComplexity, agentReputation) {
    const baseMultiplier = taskComplexity === 'high' ? 3.0 :
                          taskComplexity === 'medium' ? 2.0 : 1.5;

    // Reputation discount (0 to -0.5)
    const discount = Math.min(0, (agentReputation - 100) / 200);

    const adjustedMultiplier = baseMultiplier * (1 + discount);
    return rewardAmount.mul(Math.floor(adjustedMultiplier * 100)).div(100);
}

// Usage
const reward = ethers.utils.parseEther("1.0");
const agentRep = await agentsContract.aggregatedReputation(agentId);
const bond = calculateBond(reward, 'medium', agentRep.toNumber());

console.log(`Reward: ${ethers.utils.formatEther(reward)} ETH`);
console.log(`Bond: ${ethers.utils.formatEther(bond)} ETH`);
```

---

## Deadline Management

### No Deadlines (Flexible Tasks)

```javascript
await tasksContract.postTask(
    asset, reward, bond,
    0,  // claimWindow = 0 (no claim deadline)
    0,  // completionWindow = 0 (no completion deadline)
    metadataURI, inputURI
);
```

### Strict Deadlines

```javascript
const ONE_HOUR = 3600;
const ONE_DAY = 86400;

await tasksContract.postTask(
    asset, reward, bond,
    ONE_HOUR,      // Must be claimed within 1 hour
    6 * ONE_HOUR,  // Must be completed within 6 hours of claim
    metadataURI, inputURI
);
```

---

## Admin Functions

### pause / unpause

Emergency pause task operations.

```solidity
function pause() external onlyRole(PAUSER_ROLE)
function unpause() external onlyRole(PAUSER_ROLE)
```

---

### setTreasury

Update treasury contract address.

```solidity
function setTreasury(address newTreasury) external onlyRole(DEFAULT_ADMIN_ROLE)
```

---

## Error Reference

```solidity
error InvalidAddress();        // Zero address provided
error InvalidAmount();         // Zero or mismatched amount
error InvalidStatus();         // Task not in expected status
error AuthorizationFailed();   // Caller lacks permission
error DeadlineExpired();       // Claim/completion deadline passed
error NotAgentsContract();     // Caller not Agents.sol
error AlreadySubmitted();      // Inference already submitted
error InsufficientStake();     // Agent has no stake
```

---

## Security Considerations

### Reentrancy Protection

All state-changing functions with external calls use `nonReentrant` modifier.

### Front-Running Mitigation

- Task claims are first-come-first-served
- Consider using commit-reveal for high-value tasks

### Dispute Resolution Trust

- Dispute resolution requires trusted `DISPUTE_ROLE`
- Consider implementing DAO governance for disputes
- All resolutions are logged on-chain with reasons

### Deadline Enforcement

- Deadlines are strictly enforced
- Agents should buffer execution time
- Creators should allow reasonable completion windows

---

## Gas Optimization

1. **Use view functions**: Always call `getTask()` with `callStatic` to avoid gas costs
2. **Batch operations**: Consider batching multiple task posts in a single transaction
3. **Deadline configuration**: Set `claimWindow=0` and `completionWindow=0` if not needed
4. **Event indexing**: Use indexed parameters for efficient filtering

---

## Related Contracts

- **[Agents.sol](/contracts/agents)** - Agent registry, staking, and inference recording
- **[Treasury.sol](/contracts/treasury)** - Receives disputed task rewards and slashed bonds
- **[Subscriptions.sol](/contracts/subscriptions)** - Alternative payment model for recurring tasks

---

## ABI & Deployment

**ABI Location:** `/nexis-appchain/packages/contracts-bedrock/artifacts/contracts/Tasks.sol/Tasks.json`

**Network Addresses:**

| Network | Contract Address | Explorer |
|---------|-----------------|----------|
| Nexis Mainnet | `0x...` | [View Contract](https://explorer.nexis.network/address/0x...) |
| Nexis Testnet | `0x...` | [View Contract](https://testnet-explorer.nexis.network/address/0x...) |

---

## Support & Resources

- **GitHub:** [nexis-network/nexis-appchain](https://github.com/nexis-network/nexis-appchain)
- **Discord:** [Nexis Community](https://discord.gg/nexis)
- **Documentation:** [docs.nexis.network](https://docs.nexis.network)